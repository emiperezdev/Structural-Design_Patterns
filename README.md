# Structural Design Patterns

This repository contains examples of implementations of Structural design patterns in the book of the gang of four.

## Included Structural Design Patterns

In this project, we have implemented the following structural design patterns:

1. **Adapter Pattern**: The adapter pattern allows the interface of an existing class to be used as another interface. It is often used to make existing classes work with others without modifying their source code.

2. **Bridge Pattern**: The bridge pattern separates an object's abstraction from its implementation so that the two can vary independently. It helps in managing complex hierarchies and provides flexibility in choosing implementations.

3. **Composite Pattern**: The composite pattern allows you to compose objects into tree structures to represent part-whole hierarchies. It treats individual objects and compositions of objects uniformly.

4. **Decorator Pattern**: The decorator pattern attaches additional responsibilities to objects dynamically. It is a flexible alternative to subclassing for extending functionality.

5. **Facade Pattern**: The facade pattern provides a simplified interface to a larger body of code, making it easier to use. It acts as a high-level interface that makes a set of subsystems easier to understand and use.

6. **Flyweight Pattern**: The flyweight pattern minimizes memory usage or computational expenses by sharing as much as possible with related objects. It is particularly useful when dealing with a large number of similar objects.

7. **Proxy Pattern**: The proxy pattern provides a surrogate or placeholder for another object to control access to it. It can be used for various purposes, such as lazy initialization, access control, logging, and monitoring.

8. **Composite Pattern**: The composite pattern allows you to compose objects into tree structures to represent part-whole hierarchies. It treats individual objects and compositions of objects uniformly.

9. **Decorator Pattern**: The decorator pattern attaches additional responsibilities to objects dynamically. It is a flexible alternative to subclassing for extending functionality.

10. **Facade Pattern**: The facade pattern provides a simplified interface to a larger body of code, making it easier to use. It acts as a high-level interface that makes a set of subsystems easier to understand and use.

11. **Flyweight Pattern**: The flyweight pattern minimizes memory usage or computational expenses by sharing as much as possible with related objects. It is particularly useful when dealing with a large number of similar objects.

12. **Proxy Pattern**: The proxy pattern provides a surrogate or placeholder for another object to control access to it. It can be used for various purposes, such as lazy initialization, access control, logging, and monitoring.

## How to Use

In the "Patterns" folder, you will find code examples for each of the patterns mentioned above. You can explore these examples and learn how these patterns are implemented.

In the "Exercises" folder, you will find additional examples for each of the patterns mentioned above.

## Contributions

Contributions are welcome. If you would like to contribute to the project by adding more examples of structural design patterns or improving the documentation, please feel free to submit a pull request. Your contributions will help others learn and understand these important design patterns.
